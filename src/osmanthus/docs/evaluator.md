Poker Hand Evaluator
===

>"Do you have some aspirin?" Carmack asked his friend, as they walked into a casino in Las Vegas.  
"Do you have a headache?"  
"No," Carmack said, "but I will soon."  -- Masters of Doom

Accurate, Fast, Commercial friendly
---

### 关于牌型计算

在扑克游戏中，如何确定同样牌数下，不同组合的大小，从而确定谁胜谁负，构成了整个扑克游戏的核心玩法。  
在这里，我想简单介绍一种快速、准确，而且对商业友好的牌型评估算法。  
这个算法是由`Kevin L. Suffecool`发明的。

### 牌的阶和熵

**阶（rank）**，即扑克牌上的数字：2，3，4，5，6，7，8，9，10，J，Q，K，A  
**熵（entropy）**，即扑克牌组合后，用于和其他组合比较大小的一个度量  
例如，我们规定同花顺65432的熵为9，同花AKQJ9的熵为323，那么熵值越小的牌型越大。

**请注意**，熵这个词是笔者从物理学里借来的一个概念，由于熵可以用于衡量一个系统的混乱程度，那么在本文当中，**`其值越小，价值就越高`**。如果读者有更规范的表述，请告知，不胜感激。

### Cactus Kev's Poker Hand Evaluator

任何学过组合数学的人都知道，在5张牌的情况下，一共有C(52, 5)，即2,598,960种可能的组合，将近260万种，但是其中许多组合都有相同的熵值。例如，黑桃AJ942同花和梅花AJ942同花的熵值是一样的。尽管它们的组合都是特别的，它们拥有同样的值，在扑克中，这种熵值相同的情况就称为平局(tie)  

让我们换一种方式来看这个问题。假设你能够在足球场上聚集2,598,960个朋友，然后你给每个人5张牌，每个人都拿到那2,598,960种组合里唯一的一种。随后你大吼一声，让每个人都和其他人比较牌的大小，这个过程估计会花一些时间，随后，你让牌型最大的人站出来，显然，会有4个人站出来，他们手上拿着的是四种花色的皇家同花顺，我们将他们编号为1，然后让他们离开足球场。然后我们再让场上的人相互比较手牌，这一次是另外4个人站出来，他们手上的是K阶同花顺，我们将他们编号为2，让他们离开场地。我们不断重复这个过程，可以得到下面的数据。

|比较的次数|人数|情况|
|-------:|--:|--:|
|-|-|-- **同花顺** --|
|1|4|皇家同花顺|
|2|4|K阶同花顺|
|3|4|Q阶同花顺|
|4|4|J阶同花顺|
|5|4|10阶同花顺|
|6|4|9阶同花顺|
|7|4|8阶同花顺|
|8|4|7阶同花顺|
|9|4|6阶同花顺|
|10|4|5阶同花顺|
|-|-|-- **四条** --|
|11|4|AAAAK|
|12|4|AAAAQ|
|…|…|…|
|165|4|2224|
|166|4|2223|
|-|-|-- **葫芦** --|
|167|24|AAAKK|
|168|24|AAAQQ|
|…|…|…|
|321|24|22244|
|322|24|22233|
|-|-|-- **同花** --|
|323|4|AKQJ9|
|324|4|AKQJ8|
|…|…|…|
|1598|4|76432|
|1599|4|75432|
|-|-|-- **顺子** --|
|1600|1020|AKQJ10|
|1601|1020|KQJ109|
|…|…|…|
|1608|1020|65432|
|1609|1020|5432A|
|-|-|-- **三条** --|
|1610|64|AAAKQ|
|1611|64|AAAKJ|
|…|…|…|
|2466|64|22253|
|2467|64|22243|
|-|-|-- **两对** --|
|2468|144|AAKKQ|
|2469|144|AAKKJ|
|…|…|…|
|3324|144|33225|
|3325|144|33224|
|-|-|-- **一对** --|
|3326|384|AAKQJ|
|3327|384|AAKQT|
|…|…|…|
|6184|384|22643|
|6185|384|22543|
|-|-|-- **高牌** --|
|6186|1020|AKQJ9|
|6187|1020|AKQJ8|
|…|…|…|
|7461|1020|76432|
|7462|1020|75432|

终于，在对260万种牌型进行比较之后，我们得到下面的表  

|牌型|牌型数|熵相同的情况|
|--:|------:|-----------:|
|同花顺|40|10|
|四条|624|156|
|葫芦|3744|156|
|同花|5108|1277|
|顺子|10200|10|
|三条|54912|858|
|两对|123552|858|
|一对|1098240|2860|
|高牌|1302540|1277|
|**`总数`**|**`2598960`**|**`7462`**|

**7462**，这个数字就是5张牌的情况下，具有不同熵的组合数量，请牢记这个数字：**7462**。  

#### 数据结构

当我们知道熵只有7462种值的时候，我们需要找到将2,598,960种组合转换到对应的熵的方法。  
从复杂度上考虑，这个算法必须是顺序无关的，换句话说，如果将♦K♣Q♠J♥10♣9传递进评估函数，那么无论按什么顺序传入，都必须返回1601这个值。

这里我们可以使用质数(**`prime`**)来表示牌的阶(rank)

|Rank|Deuce|Trey|Four|Five|Six|Seven|Eight|Nine|Ten|Jack|Queen|King|Ace|
|:--:|:---:|:--:|:--:|:--:|:-:|:---:|:---:|:--:|:-:|:--:|:---:|:--:|:-:|
|Prime|2|3|5|7|11|13|17|19|23|29|31|37|41|

这个系统美妙之处就在于，如果你将手上的牌的阶相乘，你都能够得到一个唯一的值，从而巧妙的避免了排序。上面的顺子♦K♣Q♠J♥10♣9的值总是14,535,931  

不过在相乘之前，必须检查牌的花色是否构成了同花。这对于整个评估函数而言至关重要，因为同花顺比顺子的熵要低很多（熵越小，牌的组合就越大）。  

Suffecool给出了用于表示每张牌的数据结构 —— 一个32位整数，或者说，4个字节

<pre>
+--------+--------+--------+--------+
|xxxbbbbb|bbbbbbbb|cdhsrrrr|xxpppppp|
+--------+--------+--------+--------+
</pre>

其中  
p 是 代表牌阶的质数(duce = 2, trey = 3, four = 5, …, ace = 41)  
r 是 牌阶的值(duce = 0, trey = 1, four = 2, five = 3, …, ace = 12)  
cdhs 是 牌的花色(c = club梅花, d = diamond方块, h = heart红桃, s = spade黑桃)  
b 是 按照不同牌阶的标志位

其中prime的表格之前已经给出了, 下面给出不同位域的表格  

|r域|牌阶|值|
|--:|--:|--:|
|0000|2|0|
|0001|3|1|
|0010|4|2|
|0011|5|3|
|0100|6|4|
|0101|7|5|
|0110|8|6|
|0111|9|7|
|1000|10|8|
|1001|J|9|
|1010|K|10|
|1011|Q|11|
|1100|A|12|

|cdhs域|花色|值|
|--:|--:|--:|
|0001|♠|1|
|0010|♥|2|
|0100|♦|4|
|1000|♣|8|

|b域|牌阶|值|
|--:|--:|--:|
|0000000000001|2|1|
|0000000000010|3|2|
|0000000000100|4|4|
|0000000001000|5|8|
|0000000010000|6|16|
|0000000100000|7|32|
|0000001000000|8|64|
|0000010000000|9|128|
|0000100000000|10|256|
|0001000000000|J|512|
|0010000000000|Q|1024|
|0100000000000|K|2048|
|1000000000000|A|4096|

用该系统表述牌的例子:  

<pre>
xxxAKQJT 98765432 CDHSrrrr xxPPPPPP
00001000 00000000 01001011 00100101 ♦K
00000000 00001000 00010011 00000111 ♠5
00000010 00000000 10001001 00011101 ♣J
</pre>

#### 算法

现在，我们可以将代表5张牌的整数传递到评估函数中去了，将5张牌分别标记为c1, c2, c3, c4, c5  

##### 首先检查花色，看看是不是同花:  

<pre>
c1 & c2 & c3 & c4 & c5 & 0xF000		/* '&' 是位的"与"运算 */
</pre>

如果上面的表达式不为0，那么我们就得到了一个同花  

下面的图应该非常非常清晰了

<pre>
xxxAKQJT 98765432 CDHSrrrr xxPPPPPP    card/mask
-------- -------- -------- --------
xxxxxxxx xxxxxxxx ????xxxx xxxxxxxx    c1
xxxxxxxx xxxxxxxx ????xxxx xxxxxxxx    c2
xxxxxxxx xxxxxxxx ????xxxx xxxxxxxx    c3
xxxxxxxx xxxxxxxx ????xxxx xxxxxxxx    c4
xxxxxxxx xxxxxxxx ????xxxx xxxxxxxx    c5
00000000 00000000 11110000 00000000    0xF000
-------- -------- -------- --------    result
                                       00000000 00000000 ????0000 00000000
</pre>

如果我们得到的是同花，我们还需要计算出组合的熵值（即将其转换为一个1到7462之间的值）。查(水)表法（lookup table）是比较快的一种方法。  
下面的代码用于生成这个表的查询索引（下标）  

<pre>
q = (c1 | c2 | c3 | c4| c5) >> 16
</pre>

图解

<pre>
xxxAKQJT 98765432 CDHSrrrr xxPPPPPP    card/mask
-------- -------- -------- --------
xxx????? ???????? xxxxxxxx xxxxxxxx    c1
xxx????? ???????? xxxxxxxx xxxxxxxx    c2
xxx????? ???????? xxxxxxxx xxxxxxxx    c3
xxx????? ???????? xxxxxxxx xxxxxxxx    c4
xxx????? ???????? xxxxxxxx xxxxxxxx    c5
-------- -------- -------- --------    result
                                       00000000 00000000 xxx????? ????????
</pre>

注意到我们现在得到的是同花，那么5张牌的阶必定是互异的。  
我们必定能在结果的?位域上有5个置1的位。  
最小的模式应该是0x001F(31)，二进制0 0000 0001 1111， 即65432；  
最大的模式应该是0x1F00(7936)，二进制1 1111 0000 0000，即AKQJ10。  

自然的，我们需要一个大小为7937的数组，不妨称其为flushes[]。  
对于同花顺65432，索引值为31，flushes[31]的值为9 —— 因为9是同花顺65432的熵  
对于同花AKQJ9，模式为0x1E80(7808)，flushes[7808]的值应该是323 —— 因为323是同花AKQJ9的熵。  
显然，这种方式会导致数组中存在许多的冗余空间，这就是使用查找表所要付出的代价 —— 使用空间换取时间。  
不过，既然同花情况下最大的熵为7462，我们可以使用*short*类型来存放熵的值，这样，我们只需要15874bytes。并不是很大。

#####不是同花，也不是同花顺，就检查是否是顺子或是高牌:
同样的，我们还是使用查表法，建立一个名为unique5[]的数组。依然使用q作索引，如果查到的值为0，那么该组合就不是顺子或是高牌；如果查到的值不为0，那么这个值就是这5张牌的熵。例如，顺子KQJ109的模式是0x0F80(3968)，unique5[3968]的值为1601，而最烂的杂牌75432，unique5[0x002F] = unique5[47] = 7462。


####剩下的情况
使用两个简单的算法和两个查寻表，我们已经从7462个熵值中确定了其中的2574个。接下来就是质数（prime）登场的时候了  
将牌的质数提取出来并相乘:  
<pre>
q = (c1 & 0xFF) * (c2 & 0xFF) * … * (c5 & 0xFF)
</pre>

图解  

<pre>
xxxAKQJT 98765432 CDHSrrrr xxPPPPPP    card/mask
-------- -------- -------- --------
xxxxxxxx xxxxxxxx ???????? xx??????    c1
xxxxxxxx xxxxxxxx ???????? xx??????    c2
xxxxxxxx xxxxxxxx ???????? xx??????    c3
xxxxxxxx xxxxxxxx ???????? xx??????    c4
xxxxxxxx xxxxxxxx ???????? xx??????    c5
00000000 00000000 00000000 11111111    mask
-------- -------- -------- --------    result
                                       p[c1]*p[c2]*p[c3]*p[c4]*p[c5]
</pre>

这个乘积的值跨度会变得非常大  
最小值是当组合为22223时，他们的质数乘积为48；  
最大值是组合AAAAK，质数乘积为104,553,157。  

显然，这个时候使用查表法是不科学的，所以我们需要另外寻找办法。既然现在只剩下4888个熵值，我们可以使用二分查找算法。这是一种很快的算法，复杂度为O(logN)。

### 改良
Paul Senzee使用了一个完美的哈希函数取代了二分查找法，从而将原算法加速了2.7倍!

- - -

### 相关链接

[Kevin L. Suffecool的网站](http://www.suffecool.net/poker/evaluator.html)  
[Paul Senzee的网站](http://www.paulsenzee.com/2006/06/some-perfect-hash.html)
